import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Date;
import java.util.Random;

public class HashtableExperiment {

    public static void printSummary() {
        
    }
    
    public static void main(String[] args) {
        // Usage string
        String usage =  "Usage: java HashtableExperiment <dataSource> <loadFactor> [<debugLevel>]\n" + //
                        "       <dataSource>: 1 ==> random numbers\n" + //
                        "                     2 ==> date value as a long\n" + //
                        "                     3 ==> word list\n" + //
                        "       <loadFactor>: The ratio of objects to table size,\n" + //
                        "                       denoted by alpha = n/m\n" + //
                        "       <debugLevel>: 0 ==> print summary of experiment\n" + //
                        "                     1 ==> save the two hash tables to a file at the end\n" + //
                        "                     2 ==> print debugging output for each insert";

        
        if (args.length >= 2 && args.length < 4) { // check if the number of command-line arguments are valid
            try {
                /**
                 * INITIALIZING COMMAND LINE ARGUMENT VARIABLES
                 */

                // <dataSource>: Three options --> (1) Random Integers, (2) Date values as Longs, (3) Word List from text file
                int dataSource = Integer.parseInt(args[0]);
                // <loadFactor>: ratio of (n) number of stored elements to (m) number of available hash table slots
                double loadFactor = Double.parseDouble(args[1]);

                // making sure the load factor falls between 0.0 and 1.0 before using it
                if (loadFactor < 0.0 || loadFactor > 1.0) {
                    System.out.println("loadFactor should fall between 0 and 1");
                    System.out.println(usage);
                    return; // Exit main method
                }
                
                // Twin prime m between 95500 and 96000
                int m = TwinPrimeGenerator.generateTwinPrime(95500, 96000);
                int maxAllowedEntries = (int) Math.ceil(m * loadFactor);
                Random rand = new Random();
                Hashtable linearProbingTable;
                Hashtable doubleHashingTable;
                switch (dataSource) {
                    case 1:
                        // Data Source 1 <Integer>: Each HashObject contains an Integer object with a
                        // random int value generated by the method nextInt() in java.util.Random
                        // class. The key for each HashObject is the Integer object inside.
                        linearProbingTable = new LinearProbing(m, loadFactor);
                        doubleHashingTable = new DoubleHashing(m, loadFactor);

                        for (int i = 0; i < maxAllowedEntries; i++) {
                            HashObject newHashObject = new HashObject(rand.nextInt());
                            linearProbingTable.insert(newHashObject);
                            doubleHashingTable.insert(newHashObject);
                        }
                        break;
                    case 2:
                        // Each HashObject contains a Date object. We can start
                        // with the current date and save its time value.
                        linearProbingTable = new LinearProbing(m, loadFactor);
                        doubleHashingTable = new DoubleHashing(m, loadFactor);
                        long current =  new Date().getTime();

                        for (int i = 0; i < maxAllowedEntries; i++) {
                            current += 1000; //increase by 1 second (1000 ms)
                            Date date = new Date(current);
                            HashObject newHashObject = new HashObject(date);
                            linearProbingTable.insert(newHashObject);
                            doubleHashingTable.insert(newHashObject);
                        }
                        break;
                    case 3:
                        // Each HashObject contains a word from the file
                        // word-list.txt that is provided with the starter files for this project. The file
                        // contains 3,037,802 words (one per line) out of which 101,233 are unique. The key
                        // for each HashObject is the word inside represented as a String type.
                        linearProbingTable = new LinearProbing(m, loadFactor);
                        doubleHashingTable = new DoubleHashing(m, loadFactor);
                        try{
                            BufferedReader reader = new BufferedReader(new FileReader("word-list.txt"));
                            String line;
                            while ((line = reader.readLine()) != null) {
                                HashObject newHashObject = new HashObject(line);
                                linearProbingTable.insert(newHashObject);
                                doubleHashingTable.insert(newHashObject);
                            }
                            reader.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                            return; // Exit main method
                        }
                        break;
                    default:
                        System.out.println("dataSource should be 1, 2, or 3");
                        System.out.println(usage);
                        return; // Exit main method
                }


                System.out.printf("HashtableExperiment: Found a twin prime for table capacity: %d\n" +
                                "HashtableExperiment: Input: Word-List Loadfactor: %.2f\n\n", 
                                m, loadFactor);

                

                
                if (args.length == 3) {
                    // <debug-level=0,1,2>: Level of debug to output
                    int debugLevel = Integer.parseInt(args[2]);
                    switch(debugLevel) {
                        case 0:
                            // Do something
                            break;
                        case 1:
                            // Do something
                            break;
                        case 2:
                            // Do something
                            break;      
                        default: // If debug-level isn't 0,1, or 2, then by default, command-line usage is printed.
                            System.out.println("Debug Level should be 0, 1, or 2");
                            System.out.println(usage);
                            return; // Exit main method
                    }
                }
            } catch (NumberFormatException e) {
                System.out.println("Incorrect Format: Please use the correct data types for the arguments.");
                System.out.println(usage);
            }
        }
        else {
            System.out.println("Incorrect Format: Please include the correct number of arguments");
            System.out.println(usage);
        }

        // System.out.println(usage);

        // System.out.println("\nPrime number m where m and (m - 2) are both prime:\nm = " + TwinPrimeGenerator.generateTwinPrime(95500, 96000));
        // System.out.println("is m = 95791 prime: " + TwinPrimeGenerator.isPrime(95791));
        // System.out.println("is m - 2 = 95789 prime: " + TwinPrimeGenerator.isPrime(95791 - 2));

    }
}
