import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Date;
import java.util.Random;

public class HashtableExperiment {

    /**
     * Prints basic summary of a hash table in the HashExperiment
     * 
     * @param m size of the hash table represented as a twin prime number
     * @param loadFactor load factor provided for the hash table
     * @param hashTableType the type of the hash table; technically defined by its addressing technique (Linear Probing, Double Hashing, etc.)
     * @param numInsertedElements number of insert attempts on the hash table
     * @param numDuplicates number of insert attempts where duplicate HashObject was detected
     * @param avgNumProbes average number of probes performed all throughout
     */
    public static void printSummary(int m, double loadFactor, String hashTableType, int numInsertedElements, int numDuplicates, double avgNumProbes) {
        System.out.printf("        Using %s\n" +
                          "HashtableExperiment: size of hash table is %d\n" + 
                          "        Inserted %d elements, of which %d were duplicates\n" +
                          "        Avg. no. of probes = %.2f\n", 
                          hashTableType, (int) Math.ceil(m * loadFactor), numInsertedElements, numDuplicates, avgNumProbes);
    }
    
    public static void main(String[] args) {
        // Usage string
        String usage =  "Usage: java HashtableExperiment <dataSource> <loadFactor> [<debugLevel>]\n" + //
                        "       <dataSource>: 1 ==> random numbers\n" + //
                        "                     2 ==> date value as a long\n" + //
                        "                     3 ==> word list\n" + //
                        "       <loadFactor>: The ratio of objects to table size,\n" + //
                        "                       denoted by alpha = n/m\n" + //
                        "       <debugLevel>: 0 ==> print summary of experiment\n" + //
                        "                     1 ==> save the two hash tables to a file at the end\n" + //
                        "                     2 ==> print debugging output for each insert";

        
        if (args.length >= 2 && args.length < 4) { // check if the number of command-line arguments are valid
            try {
                /**
                 * INITIALIZING COMMAND LINE ARGUMENT VARIABLES
                 */

                // <dataSource>: Three options --> (1) Random Integers, (2) Date values as Longs, (3) Word List from text file
                int dataSource = Integer.parseInt(args[0]);
                // <loadFactor>: ratio of (n) number of stored elements to (m) number of available hash table slots
                double loadFactor = Double.parseDouble(args[1]);

                // making sure the load factor falls between 0.0 and 1.0 before using it
                if (loadFactor < 0.0 || loadFactor > 1.0) {
                    System.out.println("loadFactor should fall between 0 and 1");
                    System.out.println(usage);
                    return; // Exit main method
                }
                
                // Twin prime m between 95500 and 96000
                int m = TwinPrimeGenerator.generateTwinPrime(95500, 96000);
                int maxAllowedEntries = (int) Math.ceil(m * loadFactor);
                Random rand = new Random();
                Hashtable linearProbingTable;
                Hashtable doubleHashingTable;
                
                switch (dataSource) {
                    case 1:
                        // Data Source 1 <Integer>: Each HashObject contains an Integer object with a
                        // random int value generated by the method nextInt() in java.util.Random
                        // class. The key for each HashObject is the Integer object inside.
                        linearProbingTable = new LinearProbing(m, loadFactor);
                        doubleHashingTable = new DoubleHashing(m, loadFactor);

                        for (int i = 0; i < maxAllowedEntries; i++) {
                            linearProbingTable.insert(new HashObject(rand.nextInt()));
                            doubleHashingTable.insert(new HashObject(rand.nextInt()));
                        }
                        break;
                    case 2:
                        // Each HashObject contains a Date object. We can start
                        // with the current date and save its time value.
                        linearProbingTable = new LinearProbing(m, loadFactor);
                        doubleHashingTable = new DoubleHashing(m, loadFactor);
                        long current =  new Date().getTime();

                        for (int i = 0; i < maxAllowedEntries; i++) {
                            current += 1000; //increase by 1 second (1000 ms)
                            Date date = new Date(current);
                            linearProbingTable.insert(new HashObject(date));
                            doubleHashingTable.insert(new HashObject(date));
                        }
                        break;
                    case 3:
                        // Each HashObject contains a word from the file
                        // word-list.txt that is provided with the starter files for this project. The file
                        // contains 3,037,802 words (one per line) out of which 101,233 are unique. The key
                        // for each HashObject is the word inside represented as a String type.
                        linearProbingTable = new LinearProbing(m, loadFactor);
                        doubleHashingTable = new DoubleHashing(m, loadFactor);
                        try{
                            BufferedReader reader = new BufferedReader(new FileReader("word-list.txt"));
                            String line;
                            while ((line = reader.readLine()) != null) {
                                linearProbingTable.insert(new HashObject(line));
                                doubleHashingTable.insert(new HashObject(line));
                            }
                            reader.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                            return; // Exit main method
                        }
                        break;
                    default:
                        System.out.println("dataSource should be 1, 2, or 3");
                        System.out.println(usage);
                        return; // Exit main method
                }


                System.out.printf("HashtableExperiment: Found a twin prime for table capacity: %d\n" +
                                "HashtableExperiment: Input: Word-List Loadfactor: %.2f\n\n", 
                                m, loadFactor);

                

                /**
                 * Output hash table results based on debug level
                 */
                if (args.length == 3) {
                    // <debug-level=0,1,2>: Level of debug to output
                    int debugLevel = Integer.parseInt(args[2]);
                    switch(debugLevel) {
                        //Prints summary of experiment to the console containing input source type, total number 
                        // of keys inserted into the hash table, and the average number of probes.
                        case 0:
                            printSummary(m, loadFactor, "Linear Probing", 
                                    linearProbingTable.getTotalNumInsertOperations(), 
                                    linearProbingTable.getTotalNumDuplicatesDetected(), 
                                    linearProbingTable.getAvgNumProbes());
                            System.out.println();

                            printSummary(m, loadFactor, "Double Hashing", 
                                    doubleHashingTable.getTotalNumInsertOperations(), 
                                    doubleHashingTable.getTotalNumDuplicatesDetected(), 
                                    doubleHashingTable.getAvgNumProbes());
                            break;

                        // Prints summary of experiment to the console similar to debug level 0 but also saves the
                        // hash tables with number of duplicates and number of probes into two files named
                        // linear-dump.txt and double-dump.txt. 
                        case 1:
                            printSummary(m, loadFactor, "Linear Probing", 
                                    linearProbingTable.getTotalNumInsertOperations(), 
                                    linearProbingTable.getTotalNumDuplicatesDetected(), 
                                    linearProbingTable.getAvgNumProbes());
                            System.out.println("HashtableExperiment: Saved dump of hash table\n");

                            printSummary(m, loadFactor, "Double Hashing", 
                                    doubleHashingTable.getTotalNumInsertOperations(), 
                                    doubleHashingTable.getTotalNumDuplicatesDetected(), 
                                    doubleHashingTable.getAvgNumProbes());
                            System.out.println("HashtableExperiment: Saved dump of hash table");

                            try{
                                linearProbingTable.dumpToFile("word-list" + "-" + loadFactor + "-linear-dump.txt");
                                doubleHashingTable.dumpToFile("word-list" + "-" + loadFactor + "-double-dump.txt");
                            } catch (FileNotFoundException e) {
                                e.printStackTrace();
                                return; // Exit main method
                            }
                            break;
                        case 2:
                            // Do something
                            break;      
                        default: // If debug-level isn't 0,1, or 2, then by default, command-line usage is printed.
                            System.out.println("Debug Level should be 0, 1, or 2");
                            System.out.println(usage);
                            return; // Exit main method
                    }
                }
                else {
                    printSummary(m, loadFactor, "Linear Probing", 
                            linearProbingTable.getTotalNumInsertOperations(), 
                            linearProbingTable.getTotalNumDuplicatesDetected(), 
                            linearProbingTable.getAvgNumProbes());
                    System.out.println();

                    printSummary(m, loadFactor, "Double Hashing", 
                            doubleHashingTable.getTotalNumInsertOperations(), 
                            doubleHashingTable.getTotalNumDuplicatesDetected(), 
                            doubleHashingTable.getAvgNumProbes());
                }


            } catch (NumberFormatException e) {
                System.out.println("Incorrect Format: Please use the correct data types for the arguments.");
                System.out.println(usage);
            }
        }
        else {
            System.out.println("Incorrect Format: Please include the correct number of arguments");
            System.out.println(usage);
        }

        // System.out.println(usage);

        // System.out.println("\nPrime number m where m and (m - 2) are both prime:\nm = " + TwinPrimeGenerator.generateTwinPrime(95500, 96000));
        // System.out.println("is m = 95791 prime: " + TwinPrimeGenerator.isPrime(95791));
        // System.out.println("is m - 2 = 95789 prime: " + TwinPrimeGenerator.isPrime(95791 - 2));

    }
}
