import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Date;
import java.util.Random;
import java.util.Arrays;

public class HashtableExperiment {
    
    public static void main(String[] args) {
        // Usage string
        String usage =  "Usage: java HashtableExperiment <dataSource> <loadFactor> [<debugLevel>]\n" + //
                        "       <dataSource>: 1 ==> random numbers\n" + //
                        "                     2 ==> date value as a long\n" + //
                        "                     3 ==> word list\n" + //
                        "       <loadFactor>: The ratio of objects to table size,\n" + //
                        "                       denoted by alpha = n/m\n" + //
                        "       <debugLevel>: 0 ==> print summary of experiment\n" + //
                        "                     1 ==> save the two hash tables to a file at the end\n" + //
                        "                     2 ==> print debugging output for each insert";

        
        if (args.length >= 2 && args.length < 4) { // check if the number of command-line arguments are valid
            try {
                /**
                 * INITIALIZING COMMAND LINE ARGUMENT VARIABLES
                 */

                // <dataSource>: Three options --> (1) Random Integers, (2) Date values as Longs, (3) Word List from text file
                int dataSource = Integer.parseInt(args[0]);
                // <loadFactor>: ratio of (n) number of stored elements to (m) number of available hash table slots
                double loadFactor = Double.parseDouble(args[1]);

                // making sure the load factor falls between 0.0 and 1.0 before using it
                if (loadFactor < 0.0 || loadFactor > 1.0) {
                    System.out.println("loadFactor should fall between 0 and 1");
                    System.out.println(usage);
                    return; // Exit main method
                }
                
                // Twin prime m between 95500 and 96000
                int m = TwinPrimeGenerator.generateTwinPrime(95500, 96000);
                int maxAllowedEntries = (int) Math.ceil(m * loadFactor);
                Random rand = new Random();
                Hashtable linearProbingTable;
                Hashtable doubleHashingTable;

                int[] linearProbInsertOut = new int[m]; // will store the output values of LinearProbing insert() method (for debugLevel = 2)
                int[] doubleHashInsertOut = new int[m]; // will store the output values of DoubleHashing insert() method (for debugLevel = 2)
                Object[] objectFieldStorage = new Object[m]; // stores the Object key field of each HashObject (for debugLevel = 2)

                /** Counts each iteration where new HashObject objects are inserted into LinearProbing and DoubleHashing tables
                 *  in the switch statement code block below
                 */
                int countInsertionIterations = 0; 
                
                switch (dataSource) {
                    case 1:
                        // Data Source 1 <Integer>: Each HashObject contains an Integer object with a
                        // random int value generated by the method nextInt() in java.util.Random
                        // class. The key for each HashObject is the Integer object inside.
                        linearProbingTable = new LinearProbing(m, loadFactor);
                        doubleHashingTable = new DoubleHashing(m, loadFactor);

                        for (int i = 0; i < maxAllowedEntries; i++) {
                            Integer randInt = rand.nextInt();
                            linearProbInsertOut[countInsertionIterations] = linearProbingTable.insert(new HashObject(randInt));
                            doubleHashInsertOut[countInsertionIterations] = doubleHashingTable.insert(new HashObject(randInt));
                            objectFieldStorage[countInsertionIterations] = randInt;
                            countInsertionIterations++;
                        }
                        break;
                    case 2:
                        // Each HashObject contains a Date object. We can start
                        // with the current date and save its time value.
                        linearProbingTable = new LinearProbing(m, loadFactor);
                        doubleHashingTable = new DoubleHashing(m, loadFactor);
                        long current =  new Date().getTime();

                        for (int i = 0; i < maxAllowedEntries; i++) {
                            current += 1000; //increase by 1 second (1000 ms)
                            Date date = new Date(current);
                            linearProbInsertOut[countInsertionIterations] = linearProbingTable.insert(new HashObject(date));
                            doubleHashInsertOut[countInsertionIterations] = doubleHashingTable.insert(new HashObject(date));
                            objectFieldStorage[countInsertionIterations] = date;
                            countInsertionIterations++;
                        }
                        break;
                    case 3:
                        // Each HashObject contains a word from the file
                        // word-list.txt that is provided with the starter files for this project. The file
                        // contains 3,037,802 words (one per line) out of which 101,233 are unique. The key
                        // for each HashObject is the word inside represented as a String type.
                        linearProbingTable = new LinearProbing(m, loadFactor);
                        doubleHashingTable = new DoubleHashing(m, loadFactor);
                        try{
                            BufferedReader reader = new BufferedReader(new FileReader("word-list.txt"));
                            String line;
                            while ((line = reader.readLine()) != null) {
                                if (countInsertionIterations >= linearProbInsertOut.length || countInsertionIterations >= doubleHashInsertOut.length) {
                                    linearProbInsertOut = Arrays.copyOf(linearProbInsertOut, linearProbInsertOut.length * 2);
                                    doubleHashInsertOut = Arrays.copyOf(doubleHashInsertOut, doubleHashInsertOut.length * 2);
                                    objectFieldStorage = Arrays.copyOf(objectFieldStorage, objectFieldStorage.length * 2);
                                }
                                linearProbInsertOut[countInsertionIterations] = linearProbingTable.insert(new HashObject(line));
                                doubleHashInsertOut[countInsertionIterations] = doubleHashingTable.insert(new HashObject(line));
                                objectFieldStorage[countInsertionIterations] = line;
                                countInsertionIterations++;
                            }
                            reader.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                            return; // Exit main method
                        }
                        break;
                    default:
                        System.out.println("dataSource should be 1, 2, or 3");
                        System.out.println(usage);
                        return; // Exit main method
                }


                System.out.printf("HashtableExperiment: Found a twin prime for table capacity: %d\n" +
                                "HashtableExperiment: Input: Word-List Loadfactor: %.2f\n\n", 
                                m, loadFactor);

                

                /**
                 * Output hash table results based on debug level
                 */
                if (args.length == 3) {
                    // <debug-level=0,1,2>: Level of debug to output
                    int debugLevel = Integer.parseInt(args[2]);
                    switch(debugLevel) {
                        //Prints summary of experiment to the console containing input source type, total number 
                        // of keys inserted into the hash table, and the average number of probes.
                        case 0:
                            printSummary(m, loadFactor, "Linear Probing", 
                                    linearProbingTable.getTotalNumInsertOperations(), 
                                    linearProbingTable.getTotalNumDuplicatesDetected(), 
                                    linearProbingTable.getAvgNumProbes());
                            System.out.println();

                            printSummary(m, loadFactor, "Double Hashing", 
                                    doubleHashingTable.getTotalNumInsertOperations(), 
                                    doubleHashingTable.getTotalNumDuplicatesDetected(), 
                                    doubleHashingTable.getAvgNumProbes());
                            break;

                        // Prints summary of experiment to the console similar to debug level 0 but also saves the
                        // hash tables with number of duplicates and number of probes into two files named
                        // linear-dump.txt and double-dump.txt. 
                        case 1:
                            printSummary(m, loadFactor, "Linear Probing", 
                                    linearProbingTable.getTotalNumInsertOperations(), 
                                    linearProbingTable.getTotalNumDuplicatesDetected(), 
                                    linearProbingTable.getAvgNumProbes());
                            System.out.println("HashtableExperiment: Saved dump of hash table\n");

                            printSummary(m, loadFactor, "Double Hashing", 
                                    doubleHashingTable.getTotalNumInsertOperations(), 
                                    doubleHashingTable.getTotalNumDuplicatesDetected(), 
                                    doubleHashingTable.getAvgNumProbes());
                            System.out.println("HashtableExperiment: Saved dump of hash table");

                            try{
                                linearProbingTable.dumpToFile("word-list" + "-" + loadFactor + "-linear-dump.txt");
                                doubleHashingTable.dumpToFile("word-list" + "-" + loadFactor + "-double-dump.txt");
                            } catch (FileNotFoundException e) {
                                e.printStackTrace();
                                return; // Exit main method
                            }
                            break;
                        
                        // Prints element by element to the console with detailed output showing if the insert was
                        // successful or a duplicate.
                        case 2:
                            try {
                                System.out.println("...");
                                PrintWriter pw = new PrintWriter("debug-level-2-output.txt");
                                StringBuilder sb = new StringBuilder();
                                pw.println(String.format("%-40s%-50s%-50s", "No.", "Linear Probing", "Double Hashing"));
                                pw.println(String.format("%-40s%-50s%-50s", "------------------------------", 
                                                                        "----------------------------------------", 
                                                                        "----------------------------------------"));
                                for (int i = 0; i < countInsertionIterations; i++) {
                                    sb.setLength(0);
                                    String firstColumn = formatColumn(sb, sb.append("Insert #").append(i + 1).append(" --> ").append(objectFieldStorage[i]).toString(), 40);

                                    sb.setLength(0);
                                    String secondColumn;
                                    if (linearProbInsertOut[i] == -1) {secondColumn = "Insertion Terminated - Duplicate Detected";}
                                    else if (linearProbInsertOut[i] == -2) {secondColumn = "Insertion Failed - Table Reached Capacity";}
                                    else {secondColumn = sb.append("Insertion Successful after ").append(linearProbingTable.search(objectFieldStorage[i]).getProbeCount()).append(" probe(s)").toString();}
                                    secondColumn = formatColumn(sb, secondColumn, 50);
                                    
                                    sb.setLength(0);
                                    String thirdColumn;
                                    if (doubleHashInsertOut[i] == -1) {thirdColumn = "Insertion Terminated - Duplicate Detected";}
                                    else if (doubleHashInsertOut[i] == -2) {thirdColumn = "Insertion Failed - Table Reached Capacity";}
                                    else {thirdColumn = sb.append("Insertion Successful after ").append(doubleHashingTable.search(objectFieldStorage[i]).getProbeCount()).append(" probe(s)").toString();}
                                    thirdColumn = formatColumn(sb, thirdColumn, 50);

                                    // Format column for each row
                                    sb.setLength(0);
                                    sb.append(firstColumn).append(secondColumn).append(thirdColumn);
                                    // sb.append(System.lineSeparator());

                                    // Write each row into a text file for debugging
                                    pw.println(sb.toString());
                                    // System.out.print(sb.toString());
                                }
                                pw.close();
                                System.out.println("Debug-Level 2 File Write Complete!");
                            } catch (FileNotFoundException e) {
                                e.printStackTrace();
                                return; // Exit main method
                            }
                            break;      
                        default: // If debug-level isn't 0,1, or 2, then by default, command-line usage is printed.
                            System.out.println("Debug Level should be 0, 1, or 2");
                            System.out.println(usage);
                            return; // Exit main method
                    }
                }
                else {
                    printSummary(m, loadFactor, "Linear Probing", 
                            linearProbingTable.getTotalNumInsertOperations(), 
                            linearProbingTable.getTotalNumDuplicatesDetected(), 
                            linearProbingTable.getAvgNumProbes());
                    System.out.println();

                    printSummary(m, loadFactor, "Double Hashing", 
                            doubleHashingTable.getTotalNumInsertOperations(), 
                            doubleHashingTable.getTotalNumDuplicatesDetected(), 
                            doubleHashingTable.getAvgNumProbes());
                }


            } catch (NumberFormatException e) {
                System.out.println("Incorrect Format: Please use the correct data types for the arguments.");
                System.out.println(usage);
            }
        }
        else {
            System.out.println("Incorrect Format: Please include the correct number of arguments");
            System.out.println(usage);
        }

    }


    /**
     * Prints basic summary of a hash table in the HashExperiment
     * 
     * @param m size of the hash table represented as a twin prime number
     * @param loadFactor load factor provided for the hash table
     * @param hashTableType the type of the hash table; technically defined by its addressing technique (Linear Probing, Double Hashing, etc.)
     * @param numInsertedElements number of insert attempts on the hash table
     * @param numDuplicates number of insert attempts where duplicate HashObject was detected
     * @param avgNumProbes average number of probes performed all throughout
     */
    public static void printSummary(int m, double loadFactor, String hashTableType, int numInsertedElements, int numDuplicates, double avgNumProbes) {
        System.out.printf("        Using %s\n" +
                          "HashtableExperiment: size of hash table is %d\n" + 
                          "        Inserted %d elements, of which %d were duplicates\n" +
                          "        Avg. no. of probes = %.2f\n", 
                          hashTableType, (int) Math.ceil(m * loadFactor), numInsertedElements, numDuplicates, avgNumProbes);
    }

    /**
     * Helper method to format columns to a fixed width
     * 
     * @param sb {@code StringBuilder} object to be reused
     * @param content string content to modify
     * @param width fixed maximum width
     * @return formatted content string
     */
    public static String formatColumn(StringBuilder sb, String content, int width) {
        sb.setLength(0);
        if (content.length() < width) {
            // Pad with spaces to the right
            return sb.append(content).append(" ".repeat(width - content.length())).toString();
        } else {
            // Truncate if the content exceeds the width
            return sb.append(content.substring(0, width - 4)).append("... ").toString();
        }
    }

}
